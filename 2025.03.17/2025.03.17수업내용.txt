** 수업내용

React.js : 2014~2020
리액트의 전성기 : 항상 자바스크립트의 기본과 근간이 있어야 한다.

next.js : 2020 ~  현재
Remix => F/E + B/E + AI
> 프레임워크 & 라이브러리 계속 진화한다!! // 근본적인 스크립트 및 프로그래밍 언어에 대한
기본기와 이해!!

** 오늘 배울것

useMemo() = > 어떤 컴포넌트를 마운트 시킬때, 해당 컴포넌트 안에 있는 함수가 호출 되었을때,
			반환되는 값을 기억해놓도록 하는 리액트 훅 함수!!


최적화 할때 사용 : "Memoization 기법"
코드를 최적화 하는 행위를 통틀어서 부르는 명칭 = Dynamic Programming = 동적계획법 같은의미!

예시로) 내 가 무언가를 행동할때 여러사람이 와서 주체를 번거롭게 하지 않고
	 대놓고 내가 뭘 하는지 공지해놓는 또는 사전에 제시하거나 알려주는 방법들!
	내가 신상햄버거를 먹으러 갔는데 여러사람이 와서 같은 질문을 여러번 하는 것보다
	내가 뭘 하는지 공지를 띄워놓으면 간단하게 서로 해결되는 행위

	=> 용량을 최적화!
	최초의 1회를 공지 해놓고 새로 리랜더링을 할필요 없다. 메모리 누수 방지!!!

100/200/300/500 일
=> 브라우저 에서 JS를 읽은 후 실행시간 단축, 효율성 높아진다.


js => 반복해서 사용하는 코드 => 한번만 선언하고, 필요할 때마다 가져다 사용할 수 있도록
//날짜 객체 => 기념일 계산기!!
인자값만 바꾸어 처리를 했다 불필요하게 사용되어진 코드를 줄인것 => 
프로그래밍영역에서 "최적화" 라고부른다
브라우저 => JS를 읽은 후 실행 시간 단축,효율성이 높아진다!

1. H.O.C => Higher Oreder Component : 고차 컴포넌트이다.
=> 기존의 컴포넌트를 강화시키는 버전이다. 재사용가능 (중복메모리 효율적으로 사용하게)
=> 공통되는 부분에서 그 자체의 역할을 강화 <조건에 따른 전제조건 없이도 가능>
== 태생적으로 가능하게끔 / 1개의 고유명사로

2. C.C.C => Cross Cutting Component : 횡단 관심사
=> 횡단관심사는 말그대로 핵심 기능을 가로지르는 기능을 뜻한다
예) 은행 키오스크 (입금, 출금, 대출) 있으면 공통되는 보안기능(비밀번호), 예외처리 기능 등등이
    공통적으로 있는 기능들인데 (꼭거쳐야 하는) 그 기능들이 가로질러 공통되기 때문에
    그렇게 부른다.

** App이라는 컴포넌트가 존재 했을때
 
컴포넌트의 state가 변경되었을 때
> todo 객체 => 컴포넌트 리렌더링!
> 컴포넌트가 상속받은 props가 변경되었을 때
> 부모 컴포넌트가 리렌더링이 된 경우 자식 컴포넌트는 모두 리렌더링

> 컴포넌트를 재실행
>>   함수 onupdate, ondelete 재실행! 
=> 현재 발생되는 문제점 :  todo객체(최초의)가 새롭게 업데이트가 됨으로 인해서 손주컴포넌트에게
   				     본의 아니게 리랜더링이 일어나고 있다.

해결해야 되는 요소 :
todo 객체가 새롭게 생성되더라도 onUpdate함수, onDelete 함수를 재호출하고 싶지 않음!
todo 객체가 추가 업데이트가 된다면,  onCreate함수만 실행시키게 하겠다는 의미!!

A가 실행되면, B를 해라!  = > 콜백을 해라! 
** useCallback(callback, dep) : 두 번째로 입력된 의존성 배열의 값이 업데이트가 될 때에만
						callback의 실행을 시키겠다.


useCallback 이라는 리액트 훅 함수를 사용하긴 하는데, 실제 콜백함수로 입력되는
		    해당 함수의 반환값을 전달해주는 또다른 내부의 콜백함수의 인자값으로
		    state값을 전달해주면, 해당 state값은 의존성배열이 아무것도 없더라도
		    늘 항상 최신의 state값을 유지한다. (자동 업데이트)


useContext() : 부모 > 자식요소 컴포넌트(*props ) 전달가능! 
			굳이 불필요한 요소를 거쳐서 prop 를 전달하는 
			비효율적인 단계가 도출되고 있는 문제점 발견! 확인!
			스페셜한 컴포넌트이다.

** Context API를 활용해서 굉장히 특별한 컴포넌트를 하나 만들어 놓고, 해당 컴포넌트의 범위
	에 들어온 자식 컴포넌트들에게 값을 직접적으로 전달 할 수 있음 => 이때 자식 컴포넌트 들 입장
	에서는 ContextAPI 가 제공하는 값을 그냥 가져올 수는 없고,
	useContext라는 훅 함수를 통해서만 찾아올 수 있음!!

메모제이션 기법 = 최적화를 위한 기법 => 반드시 프로젝트가 종료가 되는 시기 혹은 지점에서 하는것을 권장

1) 메모이제이션을 나중에 하려고 하다보면, 중간에 props가 이동되는 경로 혹은 관리해야 하는
   state종류 들로 인해서 복잡함을 느낄수 있다. => 메모이제이션을 그때그때마다 실행!!
   => 오히려 역효과!!

=>> 어떤 역학관계에 놓여지는가에 따라서 최적화는 무용지물이 될수 있다.
=> 즉, 최종적으로 컴포넌트 구조화가 거의 혹은 모두 마무리가 되었을때 비로소 
    메모이제이션, 최적화를 해라!!

폰트 및 배경 컬러 선택할때, 참고사이드
** flat ui clolors, color hunt



