2025.01.21

** 수업내용

프로그래밍 언어
> 전통적으로 프로그래밍 언어 2가지 부류로 나눠라!
> 실행문 지향언어 vs 표현식 지향언어
> 실행문 지향언어 !!! <---- 대부분의 프로그래밍언어(많은 비율)
ex) c언어 / 자바 =>객체 지향 언어 => Js 실행문 지향언어
// 함수선언, 호출 => 로컬컴퓨터 CPU실행 > 실행된 결과를 개발자에게x 안알려준다.

> 개선 사용자에게 return 답을 입력해달라 요청하지 않고
자동으로 알수 있게 나온 언어체계
그래서 표현식 지향언어 => 루비 // 코틀린
***여기서, 자바스크립트는 실행문&표현식 모두 사용할 수 있는 언어=> 다중 패러다임 언어
자바스크립트는 **표현식 기반 언어(expression-oriented language)**의 특징을 가지면서도, 
명령형 프로그래밍(imperative programming) 스타일도 지원하기 때문이다.
(그래서, 중괄호를 써도 되고 , 안써도 여러 공식으로 써도 가능하다.)

null = 의도적으로 아무런값을 넣지않은 빈값


1.실행 컨텍스트
- variavleEnvironment
- lexicalEnvironment
> recordEnvironment
> onuterEnvironmentReference

>> scope  //  scopechain  개념을 알아야 
* this객체 로의 접근이 쉽다.

2. 제어문
> 조건문  //  반복문
1) if 문 과  if ~ else 문 : a아니면 b이다.

2) else if 문 : 여러가지 선택지를 넣어주고 싶을 때 a도 아니고 b도 아니고  c일 때

3) switch 문 (상황에 따라 가변적이어서) : 여러가지 선택지를 제공하고, 해당 선택지 가운데에서
							어떤 한가지를 선택했을 때 실행.결과값 도출!
	
**** break. 문을 써줘야 해당 참에서 멈추고 다음으로 이어지지 않는다. (종결문)
			(한줄 줄바꿈이 된다.)


location : Location { 윈도우 객체 안에 로케이션은 속성에 속한다.

alert : ƒ alert() 윈도우 객체 안에 알라트는 f가 붙어있다. 즉, 펑션 함수란 얘기이다.

/*  ** 우리가 현재 공부하고 있는 JS를 객체 지향 언어 => || Java => 객체지향언어
	자바스크립트가 밑의 과정들을 통해 돌아간다 (*원리 설명)

        => 어떠한 함수가 실행되고, 처리해야할 자료가 발생되면 기본적으로 객체라는 자료구조의 형태로
            변환해서 관리.저장.보관한다.

    ** 이러한 객체 지향 언어들은 거의 대부분 this객체를 가지고 있음! => 어떤 함수 혹은 속성값이
      실행되었을때, 실행된 함수 및 속성의 주인이 누구인지를 효율적으로 가리켜서 쉽게 찾아 올 수 있게 해주는 역할!

1. JS를 활용해서 함수선언 => 호출하는 순간 => "실행 컨텍스트" 실행
2. "실행 컨텍스트" => call stack 공간에서 가장 먼저 실행
3. 그 다음 호출된 함수가 그 위로 쌓이게 되는 구조
4. "실행 컨텍스트" => 무엇으로 구성되어 있는가 ?!
5. 
VariableEnvironment (*환경변수)
- envrionmentRecord (*snapshot) : 해당 함수가 가지고 있는 내부 함수 || 변수 등등 정보
- outerEnvironmentReference (*snapshot)
 : 해당 함수가 참조하고 있는 매개변수  || 인자값이 외부에서 들어온 경우, 어느 경로에서 유입되었는지
  에 대한 전반적인 정보

Lexicalenvironment (*사전환경정보)
- envrionmentRecord
- outerEnvironmentReference

ThisBinding (* this로 가리켜야할 대상이 누구인지의 정보를 가지고 있다.) 

// Scope (*스코프) = 유효범위
- 함수가 어디에서 어디까지를 커버해야 하는지를 결정

Scope Chain (*스코프 체인)
- 스코프 범위 내 요소를 하나씩 차례대로 검색해 나가는 프로세스
- 현재 호출된 함수의 과거 선언 당시의 Lexicalenvironment 정보까지 참조

>>> 그래서 this 가 무엇이냐???(어떻게 활용하느냐?)
 1. JS 내 전역공간(윈도우/웹브라우저)에서 this는 무조건 전역 (*모든것을 커버할 수 있다.) 객체!!
	>> Js(자바스크립트) > 어디에서 사용하려고 만들어졌나? > 바로 웹브라우저/윈도우 용이다.

2. Node.js 덕분에 global에서 사용이 가능하게 만들어 졌다.

3. 그래서 웹 브라우저 관리자 모드에서 this 를 검색할시 window와 같은 기능을 가지고 있다. 
   동일하다고 나온다.
   터미널에서 node 카테고리안 this 와 global을 검색해도 같은 기능으로 쓰이고 있다.

4. 전역에서 사용가능한 변수 = > 전역 객체안 하나의 속성값

5. 그래서 우리는 윈도우라는 큰 틀안에서 변수와 속성을 부여해서 사용하고있었던 것이다.
예시)window.prompt > (윈도우생략가능) prompt 바로 사용가능
	이 자리에  this 를 기입해도 된다. 같은 기능을 하고 있기 때문에 this.prompt 같은 의미이다.
 	이게 글로벌 전역에서 사용가능 한것이다.

6. 함수와 메서드가 같냐? 다르냐?
 this 를 대입했을때 같은 전역 global 로 읽혀야 하는데 그렇지가 않다.
어느 상황에 넣어졌느냐? 에 따라 해당 결과값이 달라진다.

why? 함수를 독립적으로 실행 시킬때에는 this를 전역객체인 window를 가리킨다.
	반면에, 함수가 특정객체의 메서드로 실행 될때에는 해당 객체를 가리킨다.

1) this를 호출하는 상황이 전역요소인지? => 100% 전역객체(window)
2) 함수를 독립적으로 호출한 상황에서 this를 요청 => window
3) 특정객체 안에 있는 속성 중 메서드를 활용해서 this를 요청했다 > 해당 객체로 불리어진 것!

 const innerFunc = () => {} 화살표 함수 : window를 찾아오지만 (콜백함수일때 무조건 이다.)
  ES6 => 2015년 업데이트 된 내용, 화살표 함수는 기존 함수들의 실행 컨텍스트와 한가지 엄청나게 큰 변화!
  실행컨텍스트 객체 >> 화살표 함수에는 thisBinding 이 없다. 생성하지 않는다.
  화살표 함수에는 부모요소의 속성을 가져오는것이다. 
**그래서 항상 window를 찾아오지 않는다. 부모가 전역이었을때 찾아옴
  콜백함수의 종속관계 요소로 화살표 함수를 많이 끌고 오긴한다. 

const self = this; // this를 해당요소 안에 변수값으로 찾아 올때 이 공식을 쓰면 된다.

변수할당 > 자료형값이 숫자인지 아닌지 여부를 판단하는것?

유효성 검사란? 아이디 중간 대문자, 특수문자를 섞어서 하는것
