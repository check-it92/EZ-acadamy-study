** 2025.03.13

** 수업내용
사이트 참조
: https://velog.io/@eeeve/%EC%9B%B9-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%8B%9D-CSR-SSR-SSG

html => dom->
css => cssom->  이 2가지 모두 비동기적 처리 방식 


후에 랜더링 작업을 거친다. 이때 이 과정을 랜더트리라고 한다. 
랜더트리에 Js, TS, 등등 여러 파일의 모음집 그것을 번들이라 하고
해당 모체가 되는 프로그램을 번들러 라고 한다. (여러개를 포함한 것) 그걸 랜더트리에 주는 과정
을 하이드레이션 (수화 : 물을준다) 라고 한다.

최초의 랜더링(컴포넌트) 이후 마운트mount 가 된다 (우리 눈앞에 보여진 시점)
=>그 것을 "FCP 과정" 을 거친다. 라고 한다. (최초의 화면에 띄워지는 과정)

이후 사용자와 상호작용하는 단계로 진행이 되는데
중간에 하이드레이션 과정(물을 주는 과정) 을 거치는데
이때 걸리는 시간이 TTI : Time TO Interaction 이라 한다.
(고용량의 파일들 : 동영상, 사진 ..등등) 으로 인해 지연될수 있다.

TTI : 	html
	Head		Body
   main   title   div   ul,li..등등

=> 해당 원본 파일을(원본돔) 	     = >>  사본파일로 복사!!! (가상돔 구조)=Virtual DOM

**  원본 파일을 스냅샷 형태!로 찍어 놓음

1) 전통방식(SSR 방식) (서버사이드 렌더링) 
: 원본의 수정이 생기면 다시 원본파일을 복사해서 > 사본에 복사 후
   1 부터 끝까지 다시 차이점을 찾느라 시간이 오래걸림
예) 엄마와 자식 : 10000개중의 무언가가 바뀌면 매번 자식이 와서 칭얼거림
			엄마 하던일 중단 후 자식을 챙기느라 바쁨 => 시간이 오래걸림!
			서버가 없으면 클라이언트(브라우저)는 아무것도 할 수 가 없음!!
			점점 양이 많아질수록 그 부담감은 커질수 밖에 없음!!
 페이지를 이동할 때마다 화면 깜박임(화면이 로드될 때마다 화면이 백지로 변하고 다시 화면이 출력되는 과정)이 있다. 

2)  CSR 방식 (클라이언트사이드 렌더링)
: 원본의 수정이 생기면 사본파일( 클라이언트에서 직접) 차이점을 비교하면서 찾음
  시간이 단축이 된다.
  그럼 수화화는 과정을 서버로부터 찾아와서 할 필요 없이 바로 클라이언트에서 비교하면서
  찾는게 가능해지므로  페이지를 이동할 때마다 화면 깜박임(화면이 로드될 때마다 화면이 백지로 변하고 다시 화면이 출력되는 과정) 적어진다. => 용량이 커져도 부담이 적어짐


----------------------------------------------------------------------------------

** 리액트
정적인 컴포넌트로 사용했었다. state

useState :  사용자가 필요로 하는 정보를 가상돔(기반)과 바로바로 소통하는! 상태를 관리해야하는
		컴포넌트의 상태를 간편하게 생성하고 업데이트 해주는 도구를 제공해준다. (리액트 훅 함수)

 		  컴포넌트가 랜더링 될때마다 특정작업을 실행할 수 있도록 하는 Hook 함수 종류들
		  (useState, useRef....등등등)
		  컴포넌트가 마운트 되었을때 최초의 랜더링
		  이후 업데이트가 되어 새로 마운트 되었을때 그것을 리랜더링이라고 한다.

=> 도큐먼트 쿼리설렉터가 먹히질 않는다 왜? html원본(DOM)이 없기 때문에
그래서 우리는 리액터에서 가상돔구조에 바로바로 생성을 해야한다. 
그렇기 때문에 hook 함수들을 쓰는데 이게 useState, useRef,  useEffect !!

useState :  리액트앱 프로젝트 안에서 관리해야 하는 상태값이 있을때,
		사용할 수 있는 리액트 훅 함수 중 하나!

useRef : 가상돔에서 마치 돔처럼 특정 노드 요소를 찾아 올수 있도록 도와주는
	   리액트 훅 함수!! useRef 를 사용하면 기본적으로 Ref객체가 탄생된다.
	   객체를 반환하는 역할을 한다.
=>> 가상돔을 객체화 할 수 있는 구조가 필요한것이다.
	   바로 이 Ref객체가 돔을 사용할 때, 주로 사용했던 document(html)의 역할을 할수 있다.
	** 따로 Node객체에 값을 부여하지않으면 탄생되어진 객체 그자체를 의미한다.
	   특정 Node랑 연결되어진것은 아니다.
	=> 해당 함수를사용하면, 정확하게 컴포넌트의 업데이트 주기에만 콜백함수를
	실행하수 있음. 의존성배열을 적용하지 않은 평상시에는 컴포넌트 마운트 시점과 업데이트시점
	 모두 콜백함수가 반흥한다.

마운트 시점 제어: 컴포넌트가 탄생되는 시점에서만 콜백함수를 실행시키고 싶은 경우!


useEffect :
		콜백 함수로 활용을 할수 있는데, 이때 두번째 인자값 = state값을 [] 배열형태로 기입을 하고
		이때, 이 두번째 인자값을 "의존성 배열 형식" 이라 한다.
		의존성 배열이 인자값제한은 없지만 state의 값만 
		WHY?? => 우리는 "가상돔" 형태에서 쓰고 있기때문에 전체를 Pathing 해서 오는 형태이다.
		전체 흐름을 쭉 읽고 온다. (그래서 console.log()를 너무 믿으면 안된다.)
		실제 event를 돌려봐야 한다.
	- 컴포넌트 의 생애주기를 관리 및 제어하기 위해서 탄생된 리액트 훅 함수!
	=> 우리가 평상시에 쓰는 인터넷 사용방법
		- 구글 프로그램 켜기 "처음 마운트"
		- 검색창 텍스트 입력 "업데이트"
		- 검색 창 완료 새로운 창 뜸 " 업데이트 -> 마운트 새로이 됨"
		- 그리고 계속해서 업데이트가 새로 뜨지 않게 "언마운트 단계 돌입"
		- 현재 화면 유지!
			

	- "의존성 배열" 을 생성한 후 해당 의존성 배열에 관리중인 state값을 적용 했을때,
	   해당 state 중 한개만 값이 바뀌어도 컴포넌트는 업데이가 되었다고 판단
	- 컴포넌트가 업데이트 (*state, props, 부모 컴포넌트의 렌더링)가 되었을때, 특정함수를 구현
	   하는 두번째 방법




1. state 값이 업데이트가 되었을때
2. 컴포넌트가 컴포넌트에게 props의 값이 변경(업데이트)되었을때  (부모가 자식에게 주는)
3. 자식요소의 입장에서 부모컴퍼넌트가 리랜더링이 되었을때

이때 자식요소가 여러개이고 한개의 값만 변경되고 나머지 값은 유지해야 할때도 있는 경우도 있다.
그때 우리는 "최적화" 과정을 거친다.

** unmount 가 제일 중요한 시점!!

사용자가 여러개의 값중 하나의 값을 사용하다 후에 다른 값으로 변경 (업데이트) 되어
새로이 마운트가 된다. 그러면 기존의 값은 사용하지 않게 되므로 
가상돔이란 구조 안에서 "언마운트" 죽게된다. => 쓰지 못하게 되는데
언마운트가 되는 순간 우리는 그 기존의 값을 써야할 경우도 있어서 "콜백"을 써야한다.

우리는 그래서 "컴포넌트의 생명주기"를 알아야 한다.

** clean-up : useEffect의 clean-up 함수 - 컴포넌트 unmount 시 반드시 있어야 하는 단계
		clean-up 함수는 useEffect Hook 내에서 return되는 함수이다.
                컴포넌트가 사라질 때(unmount 시점), 특정 값이 변경되기 직전(deps update 직전)에 
		실행할 작업을 지정할 수 있다.

---------------------------------------------------------------------------------
** React.js = 자바스크립트를 기반으로 하는 라이브러리!!!
** 라이브러리의 특징 = 개발자에게 자율성을 부여!! 기본적인 프로그래밍 언어를 기반으로
				개발자가 원하는 대로 원하는 문법을 커스텀해서 직접 사용할수 있는 권한을
				매우 많이 부여합니다.

=> 해당언어가 가지고 있는 문법 체계가 까다롭지 않다. 예) react.hook 함수를 줄테니 맘껏사용
=> 중,고급 개발자들에게는 매우 효율적이다. // 초심자들에겐 매우 불친절하다.



리액트는 Node기반으로 돌아가고 있다. 

scss 사용하는 방법
- 스타일시트 발전 단계
- less > sass > scss 이렇게 발전되어져 왔다.
- npm i sass => 터미널 에 입력 > 기존css 파일명 scss로 이름 바꿔주기
- 각 js 안에 import 되어있는 파일명 이름 scss로 바꿔주기
- 따로 wathc sass 킬 필요 없음 같은 컴파일러 이기때문에

함수에 호출되었을때 자바스크립트때 처럼
함수를 함부로 소괄호로 소출되어지면 안된다.
전체적으로 원본을 Pathing 하기 때문에 자동 실행될수 있다.

*** 만일, state 와 setSteate 와 컴포넌트가 나뉘게 된다면??

component 들을 하향식 구조로 생성!
props 값을 가진아이가 어떻게 전달을 할지 구성을 미리 계획!
그리고 각 자의 몫에 알맞게 생성
부모요소에 state를 부여해야 한다. 자식요소에 setState 를 부여!
---------------------------------------------------------------------------------
** 프레임워크의 특징 : 정해진 대로만 해야함 규격화된 문법 사용 , 유동성 떨어짐
				학습시간이 조금 길어진다. 나한테 맞추는게 아니라 내가 그 쪽에 맞춰야 해서
				(*기존 css를 아예 모르면 차라이 나을수 있음)
				알고 접근하는 순간 알고있는 지식과의 차이 때문에 충돌날수 있다.

Next.js = 프레임 워크
bootstrap = 프레임 워크
tailwind = 프레임 워크 => 개발자 전용 css!!
** 자동으로 리셋css가 먹혀져있고 내부스타일시트를(html)안에서 쓰인다.

/* 이때 구역을 나누어엇 우리는 다룰것이다!


테일윈드 = 
<font-size 비율>
	1rem = 16px 로 자동으로 인식한다.
	0.75rem = 12px
	0.5rem = 8px
	0.25rem = 4px
	이렇게 4px씩 떨어지는데 이 고유의 문법이다.

<color 시스템>
	- 텍스트 컬러 : text-컬러명-투명정도
	- 보더 컬러 : border-컬러명-투명정도
(커스텀)
텍스트 컬러 : text-[헥스코드 => #fff000] 
보더컬러 : border-[헥스코드 => #fff000] 