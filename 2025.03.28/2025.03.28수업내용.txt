** 수업내용

* 대수타입

>  Algebraic Type
= 각 타입별로 사이즈(크기)가 모두 상이하기 때문에 타입 자체를 하나의 독립된
  집합체로 인식

1. 합집합 => union 타입
2. 교집합 => intersection 타입
3. 서로소 => 서로 교집합을 공유하지 않는 혹은 못하는 집합 (숫자면 숫자, 문자면 문자)명확한 값

let a; 라고 선언만 한다면 아직 타입을 설정하지 않았기 때문에
가능성이 있어서 여러 변화를 포함한다 라는 default 값으로 any 타입으로 설정이 된다.

---------------------------------------------------------------------------

타입단언 : 단언 => 무언가를 확정지어주겠다는 의미를 가지고 있음!!
		=> 타입을 선언하는 현시점에서는 해당 타입이 아니지만, 향후 사용자로 인해서
		어떤 이벤트가 발생되어서 우리가 원하는 타입으로 변경될 것을 약속!

* 다중단언
* const 단언
* Non Null 단언
----------------------------------------------------------------------------
* 보통 유니온 타입에서 많이 일어난다. (선택사항이 많기 때문에 숫자 | 문자)

> 타입가드 : 서로소 유니온 타입의 경우, 각 타입만의 고유한 메서드 함수 등을 사용하고자
		할 때 발생하는 오류를 해결하고자 하는 목적으로 주로 사용됨.

> 타입가드 생성 시, 주로 if 조건문을 많이 사용하며, class를 통해서 생성된 내장 객체(*프로토타입)
  의 경우에는 instanceof를 사용함.

>  만약 외부에서 별도로 만든 타입별칭을 유니온 타입으로 사용한 겨웅에는 in 타입가드를 주로 사용함

* 함수 타입정의
> 매개변수 타입 정의 필수
> 함수의 반환값 타입은 매개변수 뒤에 정의
(*해당 정의는 타입추론이 가능하기 때문에 선택)
> 선택적 매개변수를 활용하는 경우에는 반드시 타입가드를 활용해야함!!
> 바닐라 자바스크립트와 동일하게 선택적 매개변수는 매개변수들 사이에서 반드시 제일 앞에 올 수 없음

*나머지 매개변수

* Type Alias를 활용해서 함수의 타입을 지정하는 경우, 재활용이 뛰어나다!!
* Type Alias 를 활용해서 호출시그니처 생성가능
 호출시그니처 : 객체타입으로 타입 별칭을 만들어 놓고, 함수의 타입으로 지정하는것을 의미!
----------------------------------------------------------------------------

* 함수타입 호환성!!
> 서로 다른 복수의 함수가 존재하는데, 해당 함수의 반환값이 있다고 전제했을때, 해당 반환값끼리
타입의 호환이 어디까지 가능할까? 우리가 그동나 공부해왔던 이론에 입각해서 사용

> 서로다른 복수의 함수가 존재하는데, 해당 함수의 매개변수가 서로 호환이 되는가?

** 함수 오버로딩 타입
=> 무언가 위에 둥둥 떠다니는 느낌!

**함수 오버로딩 타입
> 절대적인 1개의 조건값을 설정해놓고, 그외의 값을 처리하고자 하는 경우, 
  특정경우 외에는 작동하지 못하도록 하고자 할때

** 사용자 정의 타입가드

-----------------------------------------------------------------------------

*interface

왜? 타입별칭과 interface를 나누어서 써야 할까?
공통점과 차이점이 무엇일까?
https://velog.io/@wlwl99/TypeScript-type%EA%B3%BC-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4
 
> 타입별칭과 동일하게 객체타입을 정의할수 있는데, 객체내 속성값을 선택적 프로퍼티로
 설정할수 있고 읽기 전용 프로퍼티로 설정할수 있음(readonly)-> 첨삭불가

> 객체 내 메서드 함수에 대한 타입 정의도 가능함. 그런데 만약 메서드 함수내 인자값이 존재하는 경우,
호출 시그니처 형식으로 타입을 정의해야함!

> 하이브리드 타입 지정 가능!! => 두가지 기능을 동시에 할수 있다.

interface는 타입별칭에서는 존재할수 없는 확장의 개념이 존재함 = extends
** 대신 유의사항이 있다. 

 