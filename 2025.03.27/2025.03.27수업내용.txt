** 수업내용

- TYPE script!!

=> 일반적인 구조
** 컴퓨터 구조 JS -> AST (컴퓨터가 이해하는 문법으로 변환) -> Byte code
		(타입이 유연하다.)	
** Abstract Syntax Tree = 추상문법(구조) 트리 라 한다.

★약간 css를 사용할때 scss를 사용해서 자동으로 번역이 되어서 적용되게 하는 그런 원리

예시) 우리가 작성한 코드를 컴퓨터 인식하기 좋은 것으로 변환 과정을 거치고 코드로 인식이 된다.
사용자 : 
    2 + ( 3 - 1 )  =>  3 - 1 (1) -> + 2 (2) => 이 가지치는것처럼 순서가 올라가는것이 나무와 같은 구조
   컴퓨터는 2진수로 작동되기 때문이다.

** TS: type script 는 추상문법과정을 거치는 가운데  type에 대한 오류가 있는지 확인 후 컴파일링 한다.
	-> 이 단계가 추가 되었다.

= node 기반으로 작동되어진다. version 이 20버전 이상이기만 하면 된다.

=> 우리가 시작을 할때 커맨드 순서

* 초기설정
- npm init // npm init -y
- npm i @types/node (1차)
**
이 후에 로컬 + 전체 에서도 쓸수 있게끔 2차로
npm i @types/node -g (전역에서 쓸수 있게) 한번 더 설치해주는게 매너이다.
***
npm i typescript ( 타입스크립트를 자바스크립트처럼 인식해주는 app)
이후 => tsc(typescriptcompolit) -v 를 체크함으로써 설치된 버전을 확인해본다.
나오면 ok 안나온다면 -g(전역)으로 한번더 설치
이 후에 로컬 + 전체 에서도 쓸수 있게끔 2차로
npm i typescript -g (전역에서 쓸수 있게) 한번 더 설치해주는게 매너이다.
****
npx tsc 내가 변환하고자 하는 파일명
을 하면 바로 실행을 시켜서 컴파일링하기 위해 자바스크립트 파일로 변환 해준다.
(그래야 출력이 되어져서 보여지기 때문)
node index.js => 입력하면 내가 원하는 구문으로 보인다.
*****
npm i tsx 실행과 동시에 컴파일링이 되게 하는 app
- 버전 확인 tsx -v
그럼 상위단계처럼 자바스크립트로 변환해서 node로 인식되게끔 하지 않아도 바로 식별가능
- tsx 내가 원하는 파일 : 바로 터미널에 출력

이것 또한 전역에서 사용 가능하게 끔
나오면 ok 안나온다면 -g(전역)으로 한번더 설치
이 후에 로컬 + 전체 에서도 쓸수 있게끔 2차로
npm i tsx -g (전역에서 쓸수 있게) 한번 더 설치해주는게 매너이다.

(노드한테 타입스크립트를 쓸것이라고 말을 해줘야 함)
(비슷한 예시) npm i @types/styled-component

******
npm i undici-types
설치 후 사용

-------------------------------------------------------------------------------

=> 지금부터 중요 OPTION(옵셔너리한 요소) 설치

TS 프로젝트 : ESM / CJS 
ESM : Ecmascript Module : 나중에 나왔고 / 노드에서도 공식적으로 채탁한 모듈 (정식) / 대다수
CJS : Common JS Module :  노드가 탄생된 직후에는 자바스크립트의 표준 모듈을 어떻게 지정할지
					   에 대한 기준이 존재하지 않음 / 과거형

엄격하게 지정하고 있는 타입 : 부담 // 엄격
** 사람들마다 원하는 요소가 다르므로
컴파일러 요소를 옵셔너리하게 설치해준다.

1. tsc --init (타입스크립트의 옵션을 초기화 하겠다.)
그럼 tsconfig.json 파일이 생김 여기서 "전체삭제 후" 원하는 옵션 기입
{
  "include": ["src"] : 컴파일링을 하고자 하는 파일을 알아서 해당 폴더에서 찾아와서 알아서 컴파일링해라
}
그럼 우린 여기서 커맨드로 tsc 라고 만 쳐도 알아서 모든 파일이 변환된다.

2. target : 타입스크립트 파일을 자바스크립트 로 컴파일링을 하는데, 어떤 모듈버전으로 컴파일링할지
		결정해주는 옵션


CJS : require -> 형식으로 쓰인다.
ESM : import -> 받아들일때 이렇게 쓰인다. export로 내보내고 or export default

3. outDir : 컴파일링된 자바스크립트 파일을 어디에 출력(저장)해줄 것인지를 결정하는 옵션(이원화)
		(폴더만들어서 해당 폴더 등록하기)

4. moduleDetection : 타입스크립트는 기본적으로 자바스크립트와 달리 현재 루트폴더를 전역으로 인식!
				그렇기 때문에 각자 다른 파일에서 변수명이 중복되면 충돌이 일어난다 
				그것을 방지하고자.
				각자의 독립된 지역으로 쓰기 위해 쓰이는 정식적인 방법

** 디버깅요소 에 추가!
packge.json => "ts_node": "tsc && tsx src/index.ts" 우리가 커스텀으로 쓸 수 있다.
(&& 앤드단락회로)
---------------------------------------------------------------------------

1. 타입스크립트 :
기본적으로 타입스크립트는 타입주석(*Type Annotation)을 작성하도록 되어있지만 
생략을 했다고 해서 문제가 되는건 아니다.
**
자동으로 마우스를 올리기만 해도
=> "타입주석" = type annotation
=> "타입추론"=Type Inrerence 을 해준다.

원시 타입 - (자료형) number / string/ boolean / null/ undefined

리터럴 타입 ; litertal Type 

자료형 -> 참조타입(배열)

- 유니온 타입 = Union Type (합집합)

- 튜플 타입  = Tuple +> 메모리 누수를 차단하기 위해 효율적으로 사용
= 굳이 쓰지 않는데 과한 공간을 남기나, 아님 중첩해서 여러번을 과하게 쓰려고 하나?
그런 것을 방지하고자 만들어 놓은 기능

2. 참조타입 자료형 => 객체
- 컴포넌트 기반 => props => 객체

- object 객체 타입은 쓰질 않는다.!!
후에 오류가 난다. 자료값을 찾아 오려할때 ex) user.id _> 못 찾아온다.

- 많이 쓰는 방식 Interface 방식
 readonly id: number; // 고유한 식별값으로 readonly로 고정할수 있다. (읽기전용) // 속성
  name?: string; // optional property = ? : 선택적 프로퍼티 // 속성

4. 객체 타입 정하기 : 타입별칭 = type alias = as로 축약해서 쓴다.
=> Type Signature = 타입시그니쳐

Enum = 열거형 타입 // 어떤 타입을 정의 및 지정하면서 동시에
카운트가 될수 있도록 정의 할수 있다.

---------------------------------------------------------------------------------

number / string / boolean / null / undefined / array / tuple / type as / interface
= 하나의 독립적인 타입을 일종의 집합체라고 부름!!

타입 계층구조
사이트 참조
https://velog.io/@pung8146/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%95%EB%A6%AC10-%ED%83%80%EC%9E%85-%EA%B3%84%EC%B8%B5%EB%8F%84

=> 계층구조에 따라 포함을 할수 있냐? 없냐 의 차이
가로 =  형제 / 세로 = 부모
위 아래 = 슈퍼타입, 서브타입 
* upcasting : 서브타입이 슈퍼타입에 들어왔을때 쓰이는 용어 일반적인 상황
   downcasting: 특수한 상황 반대로 들어왔을때

---------------------------------------------------------------------------------
void : 의도적으로 아무런 값도 반환하지 않는 타입!

never : 애초에 반환이 아예 불가능한 타입!

***
객체 타입에 대한 호환성 -> 객체간 대수타입 비교!


