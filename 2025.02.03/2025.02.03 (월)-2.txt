2025.02.03 (월)

*** 수업내용 

1. 자바스크립트 (js)
매일 선생님이 예제를 제공해주실 것이고 그리고 우리가 그 예제를 가지고
스스로 해결할 수 있는지 그것에 대한 해결법을 찾아보기

브라우저 출력할 레이아웃 설계 할때 >> 테이블방식(table) 진짜 오래된 방식이다.  이 방식을 버려라
예시) table > table > tr > td 너무 예전 방식이고 반응형 페이지 생성시 대응 불가


**DOM 구조 형식
: 현재 우리가 보고있는 문서(html+css)를 자바스크립트가 읽기 쉽게끔 객체로 불러오는 것
우리가 브라우저에서 입력값을 주는 순간 그제서야 객체로 해서 자바스크립트가 읽어오는 것이다.


id 와 class  태그 클래스를 언제 어떻게 쓸지 생각하면서 작성하는게 좋다.

id 와 for 태그를 동일시하게 작성해주는게 좋다.

<form name="order" method="post" action="http://127.0.0.1:5500"> 폼을 쓸때의 구조
<input> 꼭 폼 구조 안에 인풋 구조를 넣어줘야 한다. ** 기능상 이 형식을 지켜주는게 좋다. (*습관화)
document.forms 이렇게 불러올 경우 
유사 배열의 형태로 구성이 되는데 HTMLCollection [form, order: form]
이 구조 안을 보면 각각의 엘리먼트 요소들 이 많기 때문에 우리가 그걸 가두는 형식으로 필요하다.

폼 형태의 구조를 쓰게 되면 배열의 형태로 => 구성이 되어있다. [0, 1, 2, 3]등으로 그래서 효율적
우리는 그 안에 innerText로 또는 value 로 객체로 불러올 수 있다.
>> 그럼 서버에서는 사용자가 무엇을 선택했는지 알수 있다.


메서드 속성을 찾아올때 어떻게 해야할까?
텍스트 안에 값을 찾아 올때는 inner-text를 많이 쓴다.
name 의 속성의 중요하다.

type 의 속성에 어떤 태그를 넣냐(text, number에 따라 해당 속성값이 달라진다.
min="1" value="1"  최소값 1과 최초의 가치값 = 초기값이 1로 나오면서 증가되는 숫자가 1씩 증가할 것이다.

<fieldset> 해당 테두리 박스를 설정해주는 것
          <legend> 해당 박스의 제목을 설정할때 사용

라벨이라는 클래스 요소 id를 줬던 그 속성값
1. 첫 번째 방법
서버가 원하는 값은 value 가치를 정해놨기 때문에 찾아올 수 있었다.
그렇기 때문에 우리가 사용하는 해당 문서에서 자바스크립트로 불러올 수 있는 것이다.
대신 실시간으로 불러올 순 없다.
document.querySelector("#product").value

아이디 태그를 사용해서 찾아오는 방법도 있다.
document.getElementById("product").value

2. 두 번째 방법
name를 사용해서 우리가 불러올 수 있다. 체인처럼 맞물려서 연결고리로 가져올 수 있다.
document.order.product.value => 이 것으로 인해 우리가 폼구조안에 인풋 구조를 반드시 넣어야 한다.

** 셀렉트 태그 생성 후 그 안에 옵션 태그를 생성하는 것이 하나의 세트 구조이다.
그래야 카테고리에서 선택을 할 수 있다.

<select name="fruit" id="items"></select>
              <option selected disabled>---- 과일 선택 ----</option> 이게 선택되지 않도록

  =>selected disabled 최초의 선택이후 변경불가 ( 명시값을 받아들이지 않도록)

              <option value="">사과</option>
              <option value="">메론</option>

radio 버튼의 의미는 여러개의 복수값중 한개를 선택하기 위한 것이므로
같은 네임값을 동일시하게 주고 value 값으로 타입을 나누는 것이다.

check box 버튼은 여러개의 값을 다중 선택할 수 있게 해주는 것

우리가 배열을 불러올때 selectIndex 를 불러서 쓸 수도 있다.

document.querySelectorAll("input[name='mailing']:checked")
체크박스를 활용해서 할 때 우리는 종류가 있기 때문에 all로 불러오고
input 태그 안 선택자를 활용해서 불러온뒤 내가 선택한 카테고리를 checked로 속성값을 알수 있다.

인풋의 넘버의 목적은 카운팅 을 하기 위한 편의성으로 쓰는 것이지 임의의 값을 입력하기 위해
적합한 속성은 아니다.

** mockup 데이터 = 프론트앤드 개발자가 필요에 따라 실제 API에서 받아온 데이터가 
			    아닌 샘플로 만든 가짜 데이터를 말합니다. 

개발자가 프로그래밍 요소 에서 중요한 역할을 구분하고자 할때  필요한 "4가지 요소!!"

- C : create - 창작
- R : read - 읽기
- U : update - 수정
- D : delete - 삭제

405 오류가 나오는 경우? > 존재하지 않는 서버에 값을 주려고 하니 오류가 생기는 것
action="http://127.0.0.1:5501" 
form태그 안에 있는  액션 태그에 우리가 서버값을 임의로 지정을
해놓았기 때문에

** 언제 button & submit 태그를 적용해야 하는가?
둘이 보기에 같은 느낌인데 뭐가 다른것인가?
++ a태그는 다른 곳으로 링크(하이퍼링크)를 이동하고자 할때 쓰인다.

button 은 비교적 나중에 나온 태그이다. 명시적으로 우리가 이름을 붙여준것일 뿐이지
기능은 같다.  조금 애매하다. 서버와 소통이 상시적이진 않다.
accept.addEventListener("click", (event) => {
  event.preventDefault();
 >> 이거 하나밖에 없다. 이벤트 핸들러는 기능은 새로고침을 할 필요 없이 자동적으로 입력 후 
      새롭게 공란이 생기는 이벤트 이다.


** - 그렇지만 submit!! 는 기본적으로 실시간으로 서버에 값을 보내는 속성을 가지고 있다.
더 실용적인 기능을 가지고 있다.
또 한가지 > 이 태그 자체가 가지고 있는 이벤트가 따로 있다.
그렇기 때문에 해당 폼태그 안에 서브밋이 가지고 있는 의미가 있기 때문에
전용 이벤트로 적용을 시키는 것이 정석적인 방법이다.

이러한 기능을 포함해서 목업데이터를 만들때 UI/UX 피그마로 활용해서 어떻게 할지
기본 설계도를 만들고 그 뒤에 프로그래밍을 시도 하는게 하나의 절차이다.

설계 도면 작성 > 설계제원/사용법/시공방법 구성 > 건축 > 기능 구현

li.append(span, button); 어팬드를 쓰면 각 요소를 다 불러올 수 있다.
				 각 개별로 불러오고 싶을 때 appendChild() 를 쓰면 된다.

ul.prepend(li); 프리팬드는 첫번째 자식요소를 뜻하는 것이다.

브라우저엔 저장공간이 있다.
크게 스토리지 라고 불리어지고 카테고리 안에
로컬과 세션 스토리지 두군데가 중요하다.

1. 로컬 스토리지는 서버자체에 삭제하지 않는 한 계속 저장이 될것이다.
			>> 보안이 취약 계속 남아있기 때문에
			>> 마우스 우클릭으로 삭제가 된다. reset 로 정보를 보호해야 한다.

2. 세션 스토리지는 브라우저가 활성화 되어있는 동안은 저장되어지지만 닫는 순간 
			저장데이터는 휘발되어 날아간다.
			>> 보안은 좋지만 순간 날아가기때문에 저장이 불편

===>>  우리 로그인할때 보통 쓰이고 피시방같은 공유컴퓨터를 사용할 경우 불안해지는데
		그럴때 세션 스토리지에서 유효기간을 설정하여 저장데이터를 날릴수 있다.

localStorage.setItem("Hello", "World"); 여기서 헬로우는 key 가 되고, 월드는 value 가 된다.

그래서 해당 값을 불러오고자 한다면 get(가져와서) 해당 key값만 입력한다면 자동으로 value가 출력이 된다.

id 는 고유해야 한다.  그래서 보통 시간과 같이 쓰인다. 현시점의 유일한 위치 (밀리단위)
예시)
 0 : {id: 1738568714637, text: '헬스장가기'}
1 : {id: 1738568728142, text: '짜'}
2 : {id: 1738568730728, text: '짜장면 먹기'


**자바스크립트의 객체 요소를 서버가 인식할 수 있게 제이슨 문법으로 바꿔줘야 한다.
	프론트 엔드와 백엔드 가 서로 상호작용할 수 있게 해주는 역할이 제이슨 이다.

 JSON.stringify(todos) 이런식으로 제이슨으로 번역한 것을 여기서 stringgify는 문자열로 받아주는 방식이다.
 JSON.parse() 이건 다시 제이슨으로 번역한 언어를 브라우저에서 통하는 언어로 바꾸는 형식

.filter() - 특정한 조건 속에서 참인 아이를 선별하는 역할

>> 02.03 (월) 숙제!!
공란에 등록을 연타했을 경우 빈 아이디값하고 텍스트 값이 나오는데
이것을 안나오게 하는 방법 > 저번에 했던 깊은비교로 if문써서 했던거 제출하기


*** 타입 스크립트란?

Typescript => Javascript Compile Language
SCSS => css Compile sheet
=>> html에서 인식할 수 있는 컴파일로 변환을 해줘야 한다.
타입스크립트는 인식이 안되기 때문에 노드로 실행을 시켜줘야 한다.
node npm 으로 실행시켜주고 각 세부사항들 선택을 해야 pekage.json이 생상된다.

각 세부사항들이 번거롭다면 올 ok로 하는 npm init -y 이 커맨드 입력시 단숨에 생성이 된다.
이후 에 노드가 타입을 인식할 수 있도록 패키지 매니저를 설치해야한다.
npm i @types/node 커맨드 입력 후 실행시키면
그후에 node_modules 폴더가 생성이 된다. 그 안에 우리가 하고자 하는 요소들을 추가하면 된다.

그리고 타입스크립트를 컴파일링 해줄 수 있는 매니저를 설치해줘야 한다.
npm i typescript 커맨드 입력

그리고 생성된 패키지 node 파일들을 함부로 삭제하면 안된다. 갖고있는 버전들의 값이 있기 때문이다.

노트북을 갖고 있는 사람들은 파일 용량이 커서 버벅일 수 있기 때문에 깃에 저장시
 노드 모듈스를 지우고 새로 파일을 활성화 해야할때마다 모듈스를 다운받아 주면 된다.
npm i 이 커맨드를 입력하면 된다.

"dependencies" {} 여기에 내가 다운받아놨던 기록들이 있기 때문에
패키지 제이슨을 지우지 않는 한 다시 재설치 시 npm i 그대로 원위치 될 것이다.

해당 언어들의 기능성을 더 키운 언어
자바스크립트에 타입을 부여한 언어입니다.
자바스크립트의 확장된 언어라고 볼 수 있습니다
(불편함을 줄이고 효율성을 키운) ** = 참조사이트 http://2024.stateofjs.com // 프로그래머스
						 프로그래머들의 해당 컴파일 프로그램 선호도
점점 선호도가 올라가기 때문에 비중을 많이 키워야 한다.



