2025.03.07. 수업내용

**  유튜브 영상 외부 가져가서 쓰고 싶을 때

<iframe width="560" height="315" 
src="https://www.youtube.com/embed/BD0bC2inuAc?si=imxDdCsGU9DeQz-k" 
title="YouTube video player" frameborder="0" 
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>

**https://www.youtube.com/embed => 통신규약 서비스로 인해서 여기까지는 공통으로 가져와야 한다.

**>> input의 네임과 id 값은 같아야 한다.

** 페이지 라우팅
인터넷을 사용하여 웹 사이트에 접속한다는 것은 브라우저를 통해서 
웹 서버에 경로 요청을 하여 웹 문서를 받아와 렌더링하는 과정이다

https://developer.themoviedb.org/reference/search-movie = tmdb 사이트

항시 리액트 사용시 해야 할 초기 단계
1.  npx create-react-app . -y
해피 해킹 완료 후
2.  npm run start

** 전통적인 자바스크립트 기반으로 홈페이지를 볼 때의 단계

index.html __
		  ]  이 두가지 모두 브라우저에서 읽게 되면서 script.js에서 읽게 된다.
style.css ____]

동시에 스크립트를 읽게 되고 충돌을 방지하기 위해 defer 을 써주게 된다. 그러므로
비동기 처리 방식으로 파일이 읽혀지게 된다.

리액트에서는 기존 전통방식  + 알파 방식으로 알아야 한다.

html - root 기본양식이 있고 이건 건들지 않을 것이다.

** React 진행 방식

html -> 문서객체 모델 (dom)의 형식을 통해 들어오게 된다
css -> 보통의 방식을 통해 진행된다.

이 2가지가 Rendering 을 통할 것이다. 하나의 주제를 통해 여러 갈래의 구조로 나올 것이다.
(= 랜더 트리) = 돔 트리와 같은 느낌
=>> 여기서 가상돔이 생성 된다. (Virtual DOM) 생성되는 이유?
=> 원본과 복제본을 만든 후 비교하기 위하여!

-> 전통방식에선 둘이 다를 경우 복제본을 완전히 바꾸게 되어 시간이 걸리는데 전체 비교하느라

-> 후 방식은 원본을 스냅샷(사진) 방식으로 유지를 하고 이후 복제본에서 바뀐점만 수정 보완
하는 방식으로 간단해진 방식이다.

이때, 스크립트가 제외되어 있는데 why? 스크립트가 1개만 있는게 아니다 여러개의 (조각)컴포넌트 구조!
여러갈래로 쪼개져 있기 때문에 랜더트리에 붙여줘야 한다.

이 랜더링이라는 과정을 거치기 때문에 자바스크립트 처럼 변수, 00 이 안된다.

++> 수화의 과정 이라 한다.(물을 주는 과정) 스크립트 = 물 > 렌더트리에 붙이는 것

여러개의 스크립트를 하나의 그룹으로 묶는 단계를 => 번들 이라 한다.

이후에 사용자에게 페이지가 마운트 되는 과정을 거친다.
여기 까지의 과정을 거쳐 사용자의 눈에 띄게 되는데 이를 FCP 라 한다.
여기서 사용자까지의 눈에 걸리는 시간 Time To Interval(TTI) 라 한다.


FCP = 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 랜더링 될때까지의 시간
즉, 웹사이트 접속 > 페이지> 텍스트,이미지 발현 까지의 시간

TTI = 브라우저가 웹 페이지의 인터페이스가 수신하는데 걸리는 시간 
즉, 페이지 요청 > 최초의 응답이 오는 데 까지 걸리는 시간

내부컴퍼넌트는 app.js 안에 하나의 컴퍼넌트를 만드는 것
+> 단점 : 가독성이 불편해질 수 있다. 길어지기 때문에

이 단점을 극복하고자 src 폴더에 다른 컴포넌트 폴더/파일을 만드는게 외부 컴포넌트이다.

리액트의 파일 이름을 Header.jsx = Header.js 동일한 파일 형식이다.

리액트 는 선언부 / 출력부 2가지로 나뉜다.
선언부 에서는 연산작업을 할것이다.


jsx 문법 
>> javascript 

1) 선언부에서 정의한 변수의 값을 중괄호로 마크업한 이후에 출력부로 가져가서 출력시킬수 있음

2) 선언부에서 선언한 변수의 값을 산술표현식으로 JSX 문법내 사용가능

3) 원시타입의 변수(자료형)들은 바로 꽂을 수 있지만 참조타입의 자료형들은 변환과정을 거쳐야 한다.
 객체의 자식들(함수, 배열) => 객체안에 있는 키는 변수이다.
** 반드시 참조타입내 하위 변수값을 선택해서 가져와야 한다.

4) JSX도 여튼 마크업 언어(열고 닫힘의)를 흉내낸 문법 <></> 꼭 열고 닫아야함
=> 일반적으로 기준

but. 컴포넌트는 <00 /> 이렇게 사용가능하기도 하고 정석대로 써도 된다.

5) 반드시 최상위 부모태그가 존재해야한다?!

** 부모요소의 div태그를 예전엔 썻지만 요새는 빈태그를 입력해도 된다.
대체제로 그게 프래그먼트 태그라 한다.

또는, import React from "react"; 상단의 값을 찾아오고 
해당 부모태그에 이 값을 기입해도 된다. <React.Fragment>
